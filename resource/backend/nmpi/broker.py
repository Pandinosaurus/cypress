#!/usr/bin/env python
# -*- coding: utf-8 -*-

#   Cypress -- A C++ interface to PyNN
#   Copyright (C) 2016 Andreas St√∂ckel
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os
import sys
import time

try:
    from urlparse import urlparse
    from urllib import urlretrieve
except ImportError:  # Py3
    from urllib.parse import urlparse
    from urllib.request import urlretrieve

# Required as the Python code is usually concatenated into a single file and
# embedded in the Cypress C++ library.
try:
    path = os.path.join(os.path.dirname(__file__),
                        "lib/nmpi")
    if os.path.exists(os.path.join(path, "nmpi_user.py")):
        sys.path.append(path)
        import nmpi_user as nmpi
except ImportError:
    pass

#
# Parse the command line
#
import argparse
parser = argparse.ArgumentParser(
    description="Command line interface to the Python part of Cypress")
parser.add_argument("--executable", type=str, action="store", required=True,
                    help="File to be executed on the NMPI")
parser.add_argument("--platform", type=str, action="store", required=True,
                    help="Target platform (NM-PM1, NM-MC1, Spikey)")
parser.add_argument("--files", type=str, action="store", default=[], nargs='*',
                    help="List of files to be uploaded to the NMPI")
parser.add_argument("--base", type=str, action="store", default=os.getcwd(),
                    help="Base directory used when determining to which " +
                         "directory the files should be extracted on the NMPI")
parser.add_argument("--args", type=str, action="store", default=[], nargs='*',
                    help="Arguments to be passed to the executable")

args = parser.parse_args()

# Create a python script which contains all the specified files and extracts
# them to a directory upon execution

# http://stackoverflow.com/questions/600268/mkdir-p-functionality-in-python
def mkdir_p(path):
    import errno
    try:
        if (path != ""):
            os.makedirs(path)
    except OSError as exc:  # Python >2.5
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else:
            raise

def tmpdirname(N):
    import random
    import string

    return ''.join(random.choice(string.ascii_uppercase +
                                 string.ascii_lowercase + string.digits) for _ in range(N))

def file_script(filename, tar_filename, execute):
    import bz2
    import base64
    import stat

    with open(filename, 'r') as fd:
        compressed = base64.b64encode(bz2.compress(fd.read()))
    return ("extract('" + tar_filename
            + "', 0o" + oct(os.stat(filename)[stat.ST_MODE])
            + ", '" + compressed + "')\n")

tmpdir = "cypress_" + tmpdirname(8)
script = """#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Automatically generated by Cypress

import base64
import bz2
import os
import subprocess
import sys

# Remember which files were extracted -- we'll cleanup our traces after running
dir = os.path.join(os.getcwd(), '""" + tmpdir + """')
files = []

# http://stackoverflow.com/questions/600268/mkdir-p-functionality-in-python
def mkdir_p(path):
    import errno
    try:
        if (path != ""):
            os.makedirs(path)
    except OSError as exc:  # Python >2.5
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else:
            raise

def extract(filename, mode, data):
    filename = os.path.join(dir, filename)
    files.append(filename)
    mkdir_p(os.path.dirname(filename))
    with open(filename, 'w') as fd:
        fd.write(bz2.decompress(base64.b64decode(data)))
    os.chmod(filename, mode)

def run(filename, args):
    old_cwd = os.getcwd()
    try:
        os.chdir(dir)
        res = subprocess.call(["./" + filename] + args)
    finally:
        os.chdir(old_cwd)

def cleanup():
    # Remove extracted files -- we're only interested in newly created files
    for file in files:
        os.unlink(file)
"""

files = args.files + [args.executable]
for filename in files:
    tar_filename = os.path.relpath(filename, args.base)
    if (tar_filename.startswith("..")):
        raise Exception(
            "Base directory must be a parent directory of all specified files!")
    script = script + file_script(filename,
                                  tar_filename,
                                  filename == args.executable)

script = script + ("res = run('" + os.path.relpath(filename, args.base)
                   + "', " + str(args.args) + ")\n")
script = script + "cleanup()\n"
script = script + "sys.exit(res)\n"

#
# Read the NMPI client configuration
#
import json

config = {}
config_file = os.path.expanduser(os.path.join("~", ".nmpi_config"))
if os.path.isfile(config_file):
    try:
        with open(config_file, 'r') as fd:
            config = json.load(fd)
    except Exception as e:
        print("Error: " + e.message)
        print("Warning: Error while parsing ~/.nmpi_config. Starting with empty configuration!")
else:
    print("Warning: ~/.nmpi_config not found. Starting with empty configuration!")

# Prompt the project name
if not "project" in config:
    config["project"] = raw_input("Project: ")

# Prompt the username
if not "username" in config:
    config["username"] = raw_input("Username: ")

# Create the client instance
token = config["token"] if "token" in config else None
while True:
    client = nmpi.Client(username=config["username"], token=token)
    config["token"] = client.token

    # Save the configuration, including the current client token
    with open(config_file, 'w') as fd:
        json.dump(config, fd, indent=4)

    # Submit the job, if this fails, explicitly query the password
    try:
        job_id = client.submit_job(source=script, platform=args.platform, project=config["project"])
    except:
        if token != None:
            token = None
            continue
        else:
            raise
    break

# Wait until the 
status = "submitted"
while True:
    new_status = client.job_status(job_id)
    if new_status != status:
        print("Job status changed: " + new_status)
        status = new_status
    if status == "error" or status == "finished":
        break
    time.sleep(1)

# Print the log
job = client.get_job(job_id)
print(job["log"])
print job

# Download the result files
datalist = job["output_data"]
for dataitem in datalist:
    url = dataitem["url"]
    (scheme, netloc, path, params, query, fragment) = urlparse(url)
#    sep = "/" + str(job_id) + "/" + tmpdir + "/" # Does not work for some reason
    sep = "/" + str(job_id) + "/"
    if sep in path:
        local_filename = path[path.rfind(sep) + len(sep):]
        mkdir_p(os.path.dirname(local_filename))
        print("Downloading " + url + " -> " + local_filename)
        urlretrieve(url, local_filename)

# Exit with the correct status
sys.exit(0 if status == "finished" else 1)

